stefan@stefans-MacBook-Pro curs07 % pwd
pwd
/Users/stefan/teaching/pf-2022-2023/curs07
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i IO
:i IO
type IO :: * -> *
newtype IO a
  = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
  	-- Defined in ‘GHC.Types’
instance Monoid a => Monoid (IO a) -- Defined in ‘GHC.Base’
instance Semigroup a => Semigroup (IO a) -- Defined in ‘GHC.Base’
instance Applicative IO -- Defined in ‘GHC.Base’
instance Functor IO -- Defined in ‘GHC.Base’
instance MonadFail IO -- Defined in ‘Control.Monad.Fail’
instance Monad IO -- Defined in ‘GHC.Base’
ghci> :i ()
:i ()
type () :: *
data () = ()
  	-- Defined in ‘GHC.Tuple’
instance Monoid () -- Defined in ‘GHC.Base’
instance Semigroup () -- Defined in ‘GHC.Base’
instance Read () -- Defined in ‘GHC.Read’
instance Bounded () -- Defined in ‘GHC.Enum’
instance Enum () -- Defined in ‘GHC.Enum’
instance Ord () -- Defined in ‘GHC.Classes’
instance Show () -- Defined in ‘GHC.Show’
instance Eq () -- Defined in ‘GHC.Classes’
ghci> ()
()
()
ghci> :t ()
:t ()
() :: ()
ghci> :i putStrLn
:i putStrLn
putStrLn :: String -> IO () 	-- Defined in ‘System.IO’
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ls -al
ls -al
total 8
drwxr-xr-x   3 stefan  staff   96 Apr  6 16:14 .
drwxr-xr-x  12 stefan  staff  384 Apr  6 15:12 ..
-rw-r--r--   1 stefan  staff  450 Apr  6 16:14 c07.hs
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o )
[2 of 2] Linking c07
stefan@stefans-MacBook-Pro curs07 % ls -al
ls -al
total 2784
drwxr-xr-x   6 stefan  staff      192 Apr  6 16:14 .
drwxr-xr-x  12 stefan  staff      384 Apr  6 15:12 ..
-rwxr-xr-x   1 stefan  staff  1411704 Apr  6 16:14 c07
-rw-r--r--   1 stefan  staff      712 Apr  6 16:14 c07.hi
-rw-r--r--   1 stefan  staff      450 Apr  6 16:14 c07.hs
-rw-r--r--   1 stefan  staff     2464 Apr  6 16:14 c07.o
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
Hello, World!
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i (>>)
:i (>>)
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  ...
  (>>) :: m a -> m b -> m b
  ...
  	-- Defined in ‘GHC.Base’
infixl 1 >>
ghci> (>>) :: IO a -> IO b -> IO b
(>>) :: IO a -> IO b -> IO b

<interactive>:2:1: error:
    • No instance for (Show (IO a0 -> IO b0 -> IO b0))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
ghci> :t (>>) :: IO a -> IO b -> IO b
:t (>>) :: IO a -> IO b -> IO b
(>>) :: IO a -> IO b -> IO b :: IO a -> IO b -> IO b
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07\
ghc c07\
> 

[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
Hello, World!
I am GHC.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
Hello, World!
I am GHC.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
Hello, World!
I am GHC.
I am done.
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i getLine
:i getLine
getLine :: IO String 	-- Defined in ‘System.IO’
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
What is your name?
Stefan
Stefan
Hello!
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :t (>>) :: IO a -> IO b -> IO b
:t (>>) :: IO a -> IO b -> IO b
(>>) :: IO a -> IO b -> IO b :: IO a -> IO b -> IO b
ghci> :i (>>=)
:i (>>=)
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  ...
  	-- Defined in ‘GHC.Base’
infixl 1 >>=
ghci> :i (>>=) :: IO a -> (a -> IO b) -> IO b
:i (>>=) :: IO a -> (a -> IO b) -> IO b

<interactive>:1:1: error: parse error on input ‘::’
ghci> :t (>>=) :: IO a -> (a -> IO b) -> IO b
:t (>>=) :: IO a -> (a -> IO b) -> IO b
(>>=) :: IO a -> (a -> IO b) -> IO b :: IO a -> (a -> IO b) -> IO b
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
Stefan
Stefan
Hello, Stefan!
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
What is your name?
Stefan
Stefan
Hello, Stefan!
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
Hello, World!
I am GHC.
I am done.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]

c07.hs:64:8: error:
    Unexpected do block in function application:
        do putStrLn "Hello, World!"
    Suggested fixes:
      • Use parentheses.
      • Perhaps you intended to use BlockArguments
   |
64 | main = do putStrLn "Hello, World!"
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
Hello, World!
I am GHC.
I am done.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
What is your name?
Stefan1
Stefan1
Hello, Stefan1!
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i (<-)
:i (<-)

<interactive>:1:2: error:
    parse error on input ‘<-’
    Suggested fix: Possibly caused by a missing 'do'?
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]

c07.hs:103:35: error:
    • Couldn't match expected type: [Char]
                  with actual type: IO String
    • In the first argument of ‘(++)’, namely ‘x’
      In the second argument of ‘(++)’, namely ‘x ++ "!"’
      In the second argument of ‘($)’, namely ‘"Hello, " ++ x ++ "!"’
    |
103 |           putStrLn $ "Hello, " ++ x ++ "!"
    |                                   ^
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]

c07.hs:103:37: error:
    • Couldn't match expected type: [Char]
                  with actual type: IO String
    • In the first argument of ‘(++)’, namely ‘x’
      In the second argument of ‘(++)’, namely ‘x ++ "!"’
      In the second argument of ‘($)’, namely ‘"Hello, " ++ x ++ "!"’
    |
103 |             putStrLn $ "Hello, " ++ x ++ "!"
    |                                     ^
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]

c07.hs:102:11: error: (let ... in ...)-syntax in pattern
    |
102 |           let x = getLine in
    |           ^^^^^^^^^^^^^^^^^^...
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
What is your name?
AAAA
AAAA
Hello, AAAA!
What is your name?
BBBB
BBBB
Hello, BBBB!
What is your name?
CCCC
CCCC
Hello, CCCC!
What is your name?
  ^C ^C^C
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
What is your name?
AAAA
AAAA
Hello, AAAA!
What is your name?
Stefan
Stefan
Hello, Stefan!
What is your name?


Done!
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]

c07.hs:129:1: error:
    parse error (possibly incorrect indentation or mismatched brackets)
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i return
:i return
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  ...
  return :: a -> m a
  	-- Defined in ‘GHC.Base’
ghci> :t return :: a -> IO a
:t return :: a -> IO a
return :: a -> IO a :: a -> IO a
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
What is your name?
Stefan
Stefan
Hello, Stefan!
What is your name?
S
S
Hello, S!
What is your name?


stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
Hello, World!
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i Monad
:i Monad
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  {-# MINIMAL (>>=) #-}
  	-- Defined in ‘GHC.Base’
instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b) => Monad ((,,) a b)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c) => Monad ((,,,) a b c)
  -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad Solo -- Defined in ‘GHC.Base’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
ghci> :ui getArgs
:ui getArgs
unknown command ':ui'
use :? for help.
ghci> :i getArgs
:i getArgs

<interactive>:1:1: error: Not in scope: ‘getArgs’
ghci> import System.IO
import System.IO
ghci> :i getArgs
:i getArgs

<interactive>:1:1: error: Not in scope: ‘getArgs’
ghci> import System.Environment
import System.Environment
ghci> :i getArgs
:i getArgs
getArgs :: IO [String] 	-- Defined in ‘System.Environment’
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07 Stefan Asdf
./c07 Stefan Asdf
["Stefan","Asdf"]
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i putStr
:i putStr
putStr :: String -> IO () 	-- Defined in ‘System.IO’
ghci> :i getProgName
:i getProgName

<interactive>:1:1: error: Not in scope: ‘getProgName’
ghci> import System.IO
import System.IO
ghci> :i getProgName
:i getProgName

<interactive>:1:1: error: Not in scope: ‘getProgName’
ghci> import System.Environment
import System.Environment
ghci> :i getProgName
:i getProgName
getProgName :: IO String 	-- Defined in ‘System.Environment’
ghci> :i (++)
:i (++)
(++) :: [a] -> [a] -> [a] 	-- Defined in ‘GHC.Base’
infixr 5 ++
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]

c07.hs:175:1: error:
    Multiple declarations of ‘main’
    Declared at: c07.hs:160:1
                 c07.hs:175:1
    |
175 | main = do args <- getArgs
    | ^^^^
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07 Stefan Asdf
./c07 Stefan Asdf
["Stefan","Asdf"]
Sunt programul c07
stefan@stefans-MacBook-Pro curs07 % pwd
pwd
/Users/stefan/teaching/pf-2022-2023/curs07
stefan@stefans-MacBook-Pro curs07 % /Users/stefan/teaching/pf-2022-2023/curs07/c07 Stefan Asdf
<rs/stefan/teaching/pf-2022-2023/curs07/c07 Stefan Asdf
["Stefan","Asdf"]
Sunt programul c07
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i openFile
:i openFile

<interactive>:1:1: error: Not in scope: ‘openFile’
ghci> import System.IO
import System.IO
ghci> :i openFile
:i openFile
openFile :: FilePath -> IOMode -> IO Handle
  	-- Defined in ‘GHC.IO.StdHandles’
ghci> :i FilePath
:i FilePath
type FilePath :: *
type FilePath = String
  	-- Defined in ‘GHC.IO’
ghci> :i IOMode
:i IOMode
type IOMode :: *
data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
  	-- Defined in ‘GHC.IO.IOMode’
instance Read IOMode -- Defined in ‘GHC.IO.IOMode’
instance Enum IOMode -- Defined in ‘GHC.IO.IOMode’
instance Ord IOMode -- Defined in ‘GHC.IO.IOMode’
instance Show IOMode -- Defined in ‘GHC.IO.IOMode’
instance Eq IOMode -- Defined in ‘GHC.IO.IOMode’
ghci> case [1,2] of [] -> "vida" | (hd:tl) -> "asdf"
case [1,2] of [] -> "vida" | (hd:tl) -> "asdf"

<interactive>:6:38: error: parse error on input ‘->’
ghci> :l c07
:l c07
[1 of 2] Compiling Main             ( c07.hs, interpreted )

c07.hs:209:32: error: parse error on input ‘|’
    |
209 | x = case [1,2] of [] -> "vida" | (hd:tl) -> "asdf"
    |                                ^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted )

c07.hs:211:8: error: parse error on input ‘|’
    |
211 |        | (hd:tl) -> "asdf"
    |        ^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted )

c07.hs:210:10: warning: [-Woverlapping-patterns]
    Pattern match is redundant
    In a case alternative: [] -> ...
    |
210 |          [] -> "vida"
    |          ^^^^^^^^^^^^
Ok, one module loaded.
ghci> x
x
"asdf"
ghci> case [1,2] of
         [] -> "vida"
         (hd:tl) -> "asdf"
case [1,2] of
*** Exception: <interactive>:11:1-13: Non-exhaustive patterns in case

ghci>          [] -> "vida"

<interactive>:12:13: error: parse error on input ‘->’
ghci>          (hd:tl) -> "asdf"

<interactive>:13:18: error: parse error on input ‘->’
ghci> case [1,2] of [] -> "vida" (hd:tl) -> "asdf"
case [1,2] of [] -> "vida" (hd:tl) -> "asdf"

<interactive>:14:36: error: parse error on input ‘->’
ghci> :i hGetContents
:i hGetContents
hGetContents :: Handle -> IO String
  	-- Defined in ‘GHC.IO.Handle.Text’
ghci> :qw
:qw
unknown command ':qw'
use :? for help.
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]

c07.hs:217:36: error:
    Variable not in scope: openFile :: String -> t0 -> IO t1
    |
217 |             (hd:_) -> do handle <- openFile hd ReadMode
    |                                    ^^^^^^^^

c07.hs:217:48: error: Data constructor not in scope: ReadMode
    |
217 |             (hd:_) -> do handle <- openFile hd ReadMode
    |                                                ^^^^^^^^

c07.hs:218:38: error:
    Variable not in scope: hGetContents :: t1 -> IO String
    Suggested fix: Perhaps use ‘getContents’ (imported from Prelude)
    |
218 |                          contents <- hGetContents handle
    |                                      ^^^^^^^^^^^^
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07 c07.hs
./c07 c07.hs
import System.Environment
import System.IO

-- Monada IO
-- = modalitatea prin care pot scrie
-- de facto programe imperative in Haskell (e.g., citesc un fisier,
-- trimit un mesaj in retea, s.a.m.d.)

-- IO a este un tip parametrizat de variabila de tip "a"

-- Valorile de tip "IO a" sunt actiuni/instructiuni/comenzi, pe care,
-- daca le execut, la sfarsit vor produce o valoare de tip "a".

-- Spun "produce" si nu "returneaza" fiindca pastrez verbul returneaza
-- pentru functii.

-- Tipul unit: ()
-- Valoarea unit: ()
-- valoarea unit este singura valoare de tip unit

-- main :: IO ()
-- main = putStrLn "Hello, World!"

-- 1. se va evalua functia numita "main" (practic, nu se intampla nimic)
-- 2. se executa actiunea intoarsa de functia "main"


-- Am doua actiuni: act1 si act2.
-- Vreau sa creez o noua actiune care sa execute intai act1 si apoi act2.

-- main :: IO ()
-- main = (>>) (putStrLn "Hello, World!")
--             (putStrLn "I am GHC.")

-- main :: IO ()
-- main = putStrLn "Hello, World!" >>
--        putStrLn "I am GHC." >>
--        putStrLn "I am done."


-- putStrLn s intoarce/returneaza o actiune IO care, daca e executata,
-- afiseaza s la iesirea standard si produce apoi valoarea ().

-- getLine :: IO String
-- getLine nu primeste niciun argument si intoarce o actiune

-- Cand execut actiunea, sistemul asteapta de la tastatura un sir de
-- caractere si apoi (dupa ce apas enter) se produce ca rezutat sirul.

-- main :: IO ()
-- main = putStrLn "What is your name?" >>
--        getLine >> -- cum "pun mana" pe sirul produs de
--                   -- actiunea intoarsa de getLine?
--        putStrLn "Hello!"

-- (>>=) :: IO a -> (a -> IO b) -> IO b

-- main :: IO ()
-- main = putStrLn "What is your name?" >>
--        getLine >>=
--        (\x -> putStrLn $ "Hello, " ++ x ++ "!")

-- Pentru monade, Haskell defineste un zahar sintactic
-- prin "notatia do" ("do" notation)

-- main :: IO ()
-- main = do putStrLn "Hello, World!"
--           putStrLn "I am GHC."
--           putStrLn "I am done."
          
-- Atentie la indentare! Daca actiunile dintr-o notatie "do" nu sunt
-- aliniate, apare o eroare la parsare.

-- main :: IO ()
-- main = do { putStrLn "Hello, World!" ;
--               putStrLn "I am GHC." ;
--            putStrLn "I am done." }

-- main :: IO ()
-- main = do
--          putStrLn "Hello, World!"
--          putStrLn "I am GHC."
--          putStrLn "I am done."

-- Cum folosim notatia "do" daca vrem "sa punem mana" pe valoarea produsa
-- de una dintre actiuni?

-- main :: IO ()
-- main = do putStrLn "What is your name?"
--           x <- getLine
--           putStrLn $ "Hello, " ++ x ++ "!"

-- Cum "dezahariseste" sistemul notatia "do"
-- main = (putStrLn "What is your name?" >>
--            (getLine >>= (\x ->
--              putStrLn $ "Hello, " ++ x ++ "!")))


-- Atentie! A nu se confunda "x <- getLine" cu "let x = getLine"

-- <- nu este o functie, face parte din notatia "do"

-- main :: IO ()
-- main = do putStrLn "What is your name?"
--           let x = getLine in do
--             y <- x
--             putStrLn $ "Hello, " ++ y ++ "!"

-- Cum obtin un comportament repetitiv?

-- main :: IO ()
-- main = do putStrLn "What is your name?"
--           name <- getLine
--           putStrLn $ "Hello, " ++ name ++ "!"
--           main

-- main :: IO ()
-- main = do putStrLn "What is your name?"
--           name <- getLine
--           if name == "" then
--             putStrLn "Done!"
--           else
--             do putStrLn $ "Hello, " ++ name ++ "!"
--                main

-- return :: a -> IO a
-- return x intoarce o actiune care, daca este executata,
-- nu face absolut nimic, dar la sfarsit produce valoarea x

-- main :: IO ()
-- main = do putStrLn "What is your name?"
--           name <- getLine
--           if name == "" then
--             return ()
--           else
--             do putStrLn $ "Hello, " ++ name ++ "!"
--                main

-- Atentie! return nu seamana deloc cu "return"-ul din C/C++/Java/Python

-- return in Haskell e doar o functie care intoarce o actiune no-op

-- return in C/C++/Java/Python e o instructiune care schimba control
-- flow-ul programului

-- main :: IO ()
-- main = do return ()
--           putStrLn "Hello, World!"


-- (G, +, ...) e grup ddaca ...

-- (M, >>=, return) e monada ddaca ...

-- IO se intampla sa satisfaca aceste proprietati

-- La sfarsit sa va arat cum pot transforma un esec intr-o lista de
-- succesuri :)

-- main :: IO ()
-- main = do args <- getArgs
--           putStrLn $ show args

-- putStr :: String -> IO ()

-- Eroare frecventa:
-- main :: IO ()
-- main = do args <- getArgs
--           putStrLn $ show args
--           putStrLn $ "Sunt programul " ++ getProgName
--                      ^^^^^^^^^^^^^^^^^    ^^^^^^^^^^^
--                          String              IO String
--          (++) :: String -> String -> String

-- main :: IO ()
-- main = do args <- getArgs
--           putStrLn $ show args
--           progName <- getProgName
--           putStrLn $ "Sunt programul " ++ progName

-- Am functia getProgName :: IO String.

-- Vreau sa imi fac functia getProgName' :: String pornind de la
-- getProgName.

-- Cum procedez? Nu se poate.

-- La fel pentru getLine :: IO String.

{-

  Daca o functie Haskell intoarce o valoare de tip IO a, functia este
de facto imperativa.

  Monada IO protejeaza toate functiile "de facto" imperative.

  Un program Haskell mai mare va fi impartit in:

  1. functii pure
  2. functii din monada IO

  Prefer sa am cat mai multe functii pure si cat mai putine functii
imperative.

  Monada IO asigura faptul ca nu risc sa contaminez o functie pura cu
un apel imperativ.

-}

-- x = case [1,2] of
--          [] -> "vida"
--          (hd:tl) -> "asdf"

main :: IO ()
main = do args <- getArgs
          case args of
            [] -> putStrLn "Dati un fisier ca argument!"
            (hd:_) -> do handle <- openFile hd ReadMode
                         contents <- hGetContents handle
                         putStrLn contents


stefan@stefans-MacBook-Pro curs07 % ls
ls
c07	c07.hi	c07.hs	c07.o
stefan@stefans-MacBook-Pro curs07 % echo "Curs 7." >> readme
echo "Curs 7." >> readme
stefan@stefans-MacBook-Pro curs07 % ls
ls
c07	c07.hi	c07.hs	c07.o	readme
stefan@stefans-MacBook-Pro curs07 % ./c07 readme
./c07 readme
Curs 7.

stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i lines
:i lines
lines :: String -> [String]
  	-- Defined in ‘base-4.17.0.0:Data.OldList’
ghci> lines "asdfas\n fds afads\n fsda fsd"
lines "asdfas\n fds afads\n fsda fsd"
["asdfas"," fds afads"," fsda fsd"]
ghci> :i unlines
:i unlines
unlines :: [String] -> String
  	-- Defined in ‘base-4.17.0.0:Data.OldList’
ghci> unlines ["asdf", "asdf1"] 
unlines ["asdf", "asdf1"] 
"asdf\nasdf1\n"
ghci> :r
:r
Ok, no modules loaded.
ghci> isComment "main :: IO ()"
isComment "main :: IO ()"

<interactive>:6:1: error:
    Variable not in scope: isComment :: String -> t
ghci> :l c07
:l c07
[1 of 2] Compiling Main             ( c07.hs, interpreted )

c07.hs:226:1: error:
    Duplicate type signatures for ‘isComment’
    at c07.hs:222:1-9
       c07.hs:226:1-9
    |
226 | isComment :: String -> Bool
    | ^^^^^^^^^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted )
Ok, one module loaded.
ghci> :l c07
:l c07
[1 of 2] Compiling Main             ( c07.hs, interpreted )
Ok, one module loaded.
ghci> isComment "main :: IO ()"
isComment "main :: IO ()"
False
ghci> isComment "--                          putStrLn contents"
isComment "--                          putStrLn contents"
True
ghci> lines "--                          contents <- hGetContents handle
--                          putStrLn contents

isComment :: String -> Bool
isComment ('-' : '-' : _) = True
"
lines "--                          contents <- hGetContents handle

<interactive>:12:67: error:
    lexical error in string/character literal at end of input
ghci> --                          putStrLn contents
ghci> 
ghci> isComment :: String -> Bool

<interactive>:15:1: error:
    • No instance for (Show (String -> Bool))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
ghci> isComment ('-' : '-' : _) = True
ghci> "

<interactive>:17:2: error:
    lexical error in string/character literal at end of input
ghci> lines "--                          contents <- hGetContents handle\n--                          putStrLn contents\n\nisComment :: String -> Bool\n
isComment ('-' : '-' : _) = True\n"
                         putStrLn contents\n\nisComment :: String -> Bool\n

<interactive>:18:147: error:
    lexical error in string/character literal at end of input
ghci> isComment ('-' : '-' : _) = True\n"

<interactive>:19:36: error:
    lexical error in string/character literal at end of input
ghci> lines "--                          contents <- hGetContents handle\n--                          putStrLn contents\n\nisComment :: String -> Bool\n
isComment ('-' : '-' : _) = True\n"
                         putStrLn contents\n\nisComment :: String -> Bool\n

<interactive>:20:147: error:
    lexical error in string/character literal at end of input
ghci> isComment ('-' : '-' : _) = True\n"

<interactive>:21:36: error:
    lexical error in string/character literal at end of input
ghci> "asdf\n"
"asdf\n"
"asdf\n"
ghci> lines "--                          contents <- hGetContents handle\n-- putStrLn contents\n\nisComment :: String -> Bool\nisComment ('-' : '-' : _) = True\n"
 True\n"
["--                          contents <- hGetContents handle","-- putStrLn contents","","isComment :: String -> Bool","isComment ('-' : '-' : _) = True"]
ghci> filter notIsComment (lines "--                          contents <- hGetContents handle\n-- putStrLn contents\n\nisComment :: String -> Bool\nisComment ('-' : '-' : _) = True\n")
ent ('-' : '-' : _) = True\n")
["","isComment :: String -> Bool","isComment ('-' : '-' : _) = True"]
ghci> proceseaza "--                          contents <- hGetContents handle\n-- putStrLn contents\n\nisComment :: String -> Bool\nisComment ('-' : '-' : _) = True\n")
 _) = True\n")

<interactive>:25:162: error: parse error on input ‘)’
ghci> proceseaza "--                          contents <- hGetContents handle\n-- putStrLn contents\n\nisComment :: String -> Bool\nisComment ('-' : '-' : _) = True\n"
 _) = True\n"
"\nisComment :: String -> Bool\nisComment ('-' : '-' : _) = True\n"
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07 c07.hs
./c07 c07.hs
import System.Environment
import System.IO




















          
































{-

  Daca o functie Haskell intoarce o valoare de tip IO a, functia este
de facto imperativa.

  Monada IO protejeaza toate functiile "de facto" imperative.

  Un program Haskell mai mare va fi impartit in:

  1. functii pure
  2. functii din monada IO

  Prefer sa am cat mai multe functii pure si cat mai putine functii
imperative.

  Monada IO asigura faptul ca nu risc sa contaminez o functie pura cu
un apel imperativ.

-}



isComment :: String -> Bool
isComment ('-' : '-' : _) = True
isComment _ = False

notIsComment :: String -> Bool
notIsComment = \line -> not (isComment line)

proceseaza :: String -> String
proceseaza contents = unlines $ filter notIsComment (lines contents)

main :: IO ()
main = do args <- getArgs
          case args of
            [] -> putStrLn "Dati un fisier ca argument!"
            (hd:_) -> do handle <- openFile hd ReadMode
                         contents <- hGetContents handle
                         putStrLn $ proceseaza contents

stefan@stefans-MacBook-Pro curs07 % ./c07 fdhsjafhadsfads
./c07 fdhsjafhadsfads
c07: fdhsjafhadsfads: openFile: does not exist (No such file or directory)
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i catch
:i catch

<interactive>:1:1: error: Not in scope: ‘catch’
ghci> import Control.Exception
import Control.Exception
ghci> :i catch
:i catch
catch :: Exception e => IO a -> (e -> IO a) -> IO a
  	-- Defined in ‘GHC.IO’
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07 c07.hs
./c07 c07.hs
import System.Environment
import System.IO
import Control.Exception




















          
































{-

  Daca o functie Haskell intoarce o valoare de tip IO a, functia este
de facto imperativa.

  Monada IO protejeaza toate functiile "de facto" imperative.

  Un program Haskell mai mare va fi impartit in:

  1. functii pure
  2. functii din monada IO

  Prefer sa am cat mai multe functii pure si cat mai putine functii
imperative.

  Monada IO asigura faptul ca nu risc sa contaminez o functie pura cu
un apel imperativ.

-}



isComment :: String -> Bool
isComment ('-' : '-' : _) = True
isComment _ = False

notIsComment :: String -> Bool
notIsComment = \line -> not (isComment line)

proceseaza :: String -> String
proceseaza contents = unlines $ filter notIsComment (lines contents)



handler :: IOException -> IO ()
handler e = putStrLn "A aparut o exceptie!"

main :: IO ()
main = do args <- getArgs
          case args of
            [] -> putStrLn "Dati un fisier ca argument!"
            (hd:_) -> catch (do handle <- openFile hd ReadMode
                                contents <- hGetContents handle
                                putStrLn $ proceseaza contents)
                            handler
                            

stefan@stefans-MacBook-Pro curs07 % ./c07 readme
./c07 readme
Curs 7.

stefan@stefans-MacBook-Pro curs07 % ./c07 adsjfhasjfhdas
./c07 adsjfhasjfhdas
A aparut o exceptie!
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07 fdjshkafds
./c07 fdjshkafds
A aparut o exceptie!
stefan@stefans-MacBook-Pro curs07 % ./c07 readme
./c07 readme
Curs 7.

stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> div 10 0
div 10 0
*** Exception: divide by zero
ghci> head []
head []
*** Exception: Prelude.head: empty list
CallStack (from HasCallStack):
  error, called at libraries/base/GHC/List.hs:1646:3 in base:GHC.List
  errorEmptyList, called at libraries/base/GHC/List.hs:85:11 in base:GHC.List
  badHead, called at libraries/base/GHC/List.hs:81:28 in base:GHC.List
  head, called at <interactive>:2:1 in interactive:Ghci1
ghci> :r
:r
Ok, no modules loaded.
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]

c07.hs:266:19: error:
    • Couldn't match type: IO ()
                     with: [Char]
      Expected: String
        Actual: IO ()
    • In the second argument of ‘($)’, namely
        ‘show (div 10 0) `catch` (\ e -> putStrLn "Eroare!")’
      In the expression:
        putStrLn $ show (div 10 0) `catch` (\ e -> putStrLn "Eroare!")
      In an equation for ‘main’:
          main
            = putStrLn $ show (div 10 0) `catch` (\ e -> putStrLn "Eroare!")
    |
266 | main = putStrLn $ show (div 10 0)
    |                   ^^^^^^^^^^^^^^^...
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]

c07.hs:267:8: error:
    • Ambiguous type variable ‘e0’ arising from a use of ‘catch’
      prevents the constraint ‘(Exception e0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘e0’ should be.
      Potentially matching instances:
        instance Exception ArithException
          -- Defined in ‘GHC.Exception.Type’
        instance Exception SomeException -- Defined in ‘GHC.Exception.Type’
        ...plus 10 others
        ...plus two instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression:
        (putStrLn $ show (div 10 0)) `catch` (\ e -> putStrLn "Eroare!")
      In an equation for ‘main’:
          main
            = (putStrLn $ show (div 10 0)) `catch` (\ e -> putStrLn "Eroare!")
    |
267 |        `catch`
    |        ^^^^^^^
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i Exception
:i Exception

<interactive>:1:1: error: Not in scope: ‘Exception’
ghci> import Control.Exception

import Control.Exception
ghci> 
ghci> :i Exception
:i Exception
type Exception :: * -> Constraint
class (base-4.17.0.0:Data.Typeable.Internal.Typeable e, Show e) =>
      Exception e where
  toException :: e -> SomeException
  fromException :: SomeException -> Maybe e
  displayException :: e -> String
  	-- Defined in ‘GHC.Exception.Type’
instance Exception NestedAtomically
  -- Defined in ‘Control.Exception.Base’
instance Exception NoMethodError
  -- Defined in ‘Control.Exception.Base’
instance Exception NonTermination
  -- Defined in ‘Control.Exception.Base’
instance Exception PatternMatchFail
  -- Defined in ‘Control.Exception.Base’
instance Exception RecConError
  -- Defined in ‘Control.Exception.Base’
instance Exception RecSelError
  -- Defined in ‘Control.Exception.Base’
instance Exception RecUpdError
  -- Defined in ‘Control.Exception.Base’
instance Exception TypeError -- Defined in ‘Control.Exception.Base’
instance Exception ErrorCall -- Defined in ‘GHC.Exception’
instance Exception ArithException
  -- Defined in ‘GHC.Exception.Type’
instance Exception SomeException -- Defined in ‘GHC.Exception.Type’
instance Exception AllocationLimitExceeded
  -- Defined in ‘GHC.IO.Exception’
instance Exception ArrayException -- Defined in ‘GHC.IO.Exception’
instance Exception AssertionFailed -- Defined in ‘GHC.IO.Exception’
instance Exception AsyncException -- Defined in ‘GHC.IO.Exception’
instance Exception BlockedIndefinitelyOnMVar
  -- Defined in ‘GHC.IO.Exception’
instance Exception BlockedIndefinitelyOnSTM
  -- Defined in ‘GHC.IO.Exception’
instance Exception CompactionFailed
  -- Defined in ‘GHC.IO.Exception’
instance Exception Deadlock -- Defined in ‘GHC.IO.Exception’
instance Exception IOException -- Defined in ‘GHC.IO.Exception’
instance Exception SomeAsyncException
  -- Defined in ‘GHC.IO.Exception’
ghci> :q
:q
Leaving GHCi.
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
Eroare!
stefan@stefans-MacBook-Pro curs07 % ghc c07
ghc c07
[1 of 2] Compiling Main             ( c07.hs, c07.o ) [Source file changed]
[2 of 2] Linking c07 [Objects changed]
stefan@stefans-MacBook-Pro curs07 % ./c07
./c07
c07: divide by zero
stefan@stefans-MacBook-Pro curs07 % ghci
ghci
GHCi, version 9.4.4: https://www.haskell.org/ghc/  :? for help
ghci> :i Maybe
:i Maybe
type Maybe :: * -> *
data Maybe a = Nothing | Just a
  	-- Defined in ‘GHC.Maybe’
instance Semigroup a => Monoid (Maybe a) -- Defined in ‘GHC.Base’
instance Semigroup a => Semigroup (Maybe a)
  -- Defined in ‘GHC.Base’
instance Foldable Maybe -- Defined in ‘Data.Foldable’
instance Traversable Maybe -- Defined in ‘Data.Traversable’
instance Read a => Read (Maybe a) -- Defined in ‘GHC.Read’
instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance MonadFail Maybe -- Defined in ‘Control.Monad.Fail’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’
instance Ord a => Ord (Maybe a) -- Defined in ‘GHC.Maybe’
ghci> :i return
:i return
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  ...
  return :: a -> m a
  	-- Defined in ‘GHC.Base’
ghci> :r
:r
Ok, no modules loaded.
ghci> returnMaybe "10"
returnMaybe "10"

<interactive>:4:1: error:
    Variable not in scope: returnMaybe :: String -> t
ghci> :l c07
:l c07
[1 of 2] Compiling Main             ( c07.hs, interpreted )
Ok, one module loaded.
ghci> returnMaybe "10"
returnMaybe "10"
Just "10"
ghci> returnMaybe "asf"
returnMaybe "asf"
Just "asf"
ghci> returnMaybe True
returnMaybe True
Just True
ghci> returnMaybe 10
returnMaybe 10
Just 10
ghci> :i (>>=)
:i (>>=)
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  ...
  	-- Defined in ‘GHC.Base’
infixl 1 >>=
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted ) [Source file changed]

c07.hs:289:17: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘==’
      prevents the constraint ‘(Eq a0)’ from being solved.
      Relevant bindings include
        x :: Maybe a0 (bound at c07.hs:289:7)
        w1 :: Maybe a0 -> Maybe a0 (bound at c07.hs:289:1)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance (Eq a, Eq b) => Eq (Either a b)
          -- Defined in ‘Data.Either’
        instance Eq ErrorCall -- Defined in ‘GHC.Exception’
        ...plus 38 others
        ...plus 59 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: x == 0
      In the expression: if x == 0 then Nothing else div 10 x
      In the expression: \ x -> if x == 0 then Nothing else div 10 x
    |
289 | w1 = \x -> if x == 0 then Nothing else div 10 x
    |                 ^^

c07.hs:289:20: error:
    • No instance for (Num (Maybe a0)) arising from the literal ‘0’
    • In the second argument of ‘(==)’, namely ‘0’
      In the expression: x == 0
      In the expression: if x == 0 then Nothing else div 10 x
    |
289 | w1 = \x -> if x == 0 then Nothing else div 10 x
    |                    ^

c07.hs:289:40: error:
    • No instance for (Integral (Maybe a0)) arising from a use of ‘div’
    • In the expression: div 10 x
      In the expression: if x == 0 then Nothing else div 10 x
      In the expression: \ x -> if x == 0 then Nothing else div 10 x
    |
289 | w1 = \x -> if x == 0 then Nothing else div 10 x
    |                                        ^^^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted )
Ok, one module loaded.
ghci> v1
v1
Nothing
ghci> v2
v2
Just 10
ghci> w1
w1

<interactive>:15:1: error:
    • No instance for (Show (Int -> Maybe Int))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
ghci> w1 10
w1 10
Just 1
ghci> w1 100
w1 100
Just 0
ghci> w1 2
w1 2
Just 5
ghci> seqMaybe v1 w1
seqMaybe v1 w1
Nothing
ghci> seqMaybe v2 w1
seqMaybe v2 w1
Just 1
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> seqMaybe v3 w1
seqMaybe v3 w1
Nothing
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> impartireInLant 100 2 5
impartireInLant 100 2 5
Just 10
ghci> impartireInLant 100 5 5
impartireInLant 100 5 5
Just 4
ghci> impartireInLant 100 1005 5
impartireInLant 100 1005 5
Just 0
ghci> impartireInLant 100 0 5
impartireInLant 100 0 5
Nothing
ghci> impartireInLant 100 5 0
impartireInLant 100 5 0
Nothing
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> impartireInLant 100 5 5
impartireInLant 100 5 5
Just 4
ghci> impartireInLant 100 5 2
impartireInLant 100 5 2
Just 10
ghci> impartireInLant 100 0 5
impartireInLant 100 0 5
Nothing
ghci> impartireInLant 100 5 0
impartireInLant 100 5 0
Nothing
ghci> impartireInLant 100 5 5
impartireInLant 100 5 5
Just 4
ghci> :i []
:i []
type [] :: * -> *
data [] a = [] | a : [a]
  	-- Defined in ‘GHC.Types’
instance Traversable [] -- Defined in ‘Data.Traversable’
instance MonadFail [] -- Defined in ‘Control.Monad.Fail’
instance Monoid [a] -- Defined in ‘GHC.Base’
instance Semigroup [a] -- Defined in ‘GHC.Base’
instance Foldable [] -- Defined in ‘Data.Foldable’
instance Applicative [] -- Defined in ‘GHC.Base’
instance Monad [] -- Defined in ‘GHC.Base’
instance Functor [] -- Defined in ‘GHC.Base’
instance Eq a => Eq [a] -- Defined in ‘GHC.Classes’
instance Ord a => Ord [a] -- Defined in ‘GHC.Classes’
instance Read a => Read [a] -- Defined in ‘GHC.Read’
instance Show a => Show [a] -- Defined in ‘GHC.Show’
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> returnList 10
returnList 10
[10]
ghci> returnList "asdf"
returnList "asdf"
["asdf"]
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :t seqList
:t seqList
seqList :: [a] -> (a -> [b]) -> [b]
ghci> "r
"r

<interactive>:41:3: error:
    lexical error in string/character literal at end of input
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> f 10
f 10
[1,2,3,4,5,6,7,8,9,10]
ghci> f 20-
f 20-

<interactive>:44:6: error:
    parse error (possibly incorrect indentation or mismatched brackets)
ghci> f 20
f 20
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci> seqList [1, 4, 8] f
seqList [1, 4, 8] f
[1,1,2,3,4,1,2,3,4,5,6,7,8]
ghci> :r
:r
[1 of 2] Compiling Main             ( c07.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> impartireInLant' 100 5 5
impartireInLant' 100 5 5
[4]
ghci> impartireInLant' 100 2 5
impartireInLant' 100 2 5
[10]
ghci> impartireInLant' 100 5 1
impartireInLant' 100 5 1
[20]
ghci> impartireInLant' 100 0 5
impartireInLant' 100 0 5
[]
ghci> impartireInLant' 100 5 0
impartireInLant' 100 5 0
[]
ghci> 