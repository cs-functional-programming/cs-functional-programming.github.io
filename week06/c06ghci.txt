stefan@stefans-MBP week06 % ghci
ghci
GHCi, version 9.4.8: https://www.haskell.org/ghc/  :? for help
macro 'doc' overwrites builtin command.  Use ':def!' to overwrite.
Loaded GHCi configuration from /Users/stefan/.ghci
ghci> :l c06
:l c06
[1 of 2] Compiling Main             ( c06.hs, interpreted )
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :t Mon
:t Mon
Mon :: Dow
ghci> Mon == Mon
Mon == Mon

<interactive>:4:5: error:
    • No instance for (Eq Dow) arising from a use of ‘==’
    • In the expression: Mon == Mon
      In an equation for ‘it’: it = Mon == Mon
ghci> :info Eq
:info Eq
type Eq :: * -> Constraint
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘GHC.Classes’
instance Eq () -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b) => Eq (a, b) -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c) => Eq (a, b, c)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) =>
         Eq (a, b, c, d, e, f)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) =>
         Eq (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) =>
         Eq (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) =>
         Eq (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j) =>
         Eq (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n, Eq o) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Classes’
instance Eq Bool -- Defined in ‘GHC.Classes’
instance Eq Char -- Defined in ‘GHC.Classes’
instance Eq Double -- Defined in ‘GHC.Classes’
instance Eq Float -- Defined in ‘GHC.Classes’
instance Eq Int -- Defined in ‘GHC.Classes’
instance Eq Ordering -- Defined in ‘GHC.Classes’
instance Eq a => Eq (Solo a) -- Defined in ‘GHC.Classes’
instance Eq Word -- Defined in ‘GHC.Classes’
instance Eq a => Eq [a] -- Defined in ‘GHC.Classes’
instance Eq Integer -- Defined in ‘GHC.Num.Integer’
instance (Eq a, Eq b) => Eq (Either a b)
  -- Defined in ‘Data.Either’
instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Mon == Mon
Mon == Mon
True
ghci> Mon == Tue
Mon == Tue
False
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Succ (Succ Zero) == Succ (Succ Zero)
Succ (Succ Zero) == Succ (Succ Zero)
True
ghci> Succ (Succ Zero) == Succ (Succ (Succ Zero))
Succ (Succ Zero) == Succ (Succ (Succ Zero))
False
ghci> Neg (Succ (Succ Zero)) == Pos (Succ (Succ Zero))
Neg (Succ (Succ Zero)) == Pos (Succ (Succ Zero))

<interactive>:12:1: error:
    Data constructor not in scope: Neg :: Nat -> a0

<interactive>:12:27: error:
    Data constructor not in scope: Pos :: Nat -> a0
    Suggested fix: Perhaps use variable ‘cos’ (imported from Prelude)
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Neg (Succ (Succ Zero)) == Pos (Succ (Succ Zero))
Neg (Succ (Succ Zero)) == Pos (Succ (Succ Zero))
False
ghci> Neg Zero == Pos Zero
Neg Zero == Pos Zero
False
ghci> :i Eq
:i Eq
type Eq :: * -> Constraint
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘GHC.Classes’
instance Eq Dow -- Defined at c06.hs:5:61
instance Eq Nat -- Defined at c06.hs:7:37
instance Eq Z -- Defined at c06.hs:9:37
instance Eq () -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b) => Eq (a, b) -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c) => Eq (a, b, c)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) =>
         Eq (a, b, c, d, e, f)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) =>
         Eq (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) =>
         Eq (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) =>
         Eq (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j) =>
         Eq (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n, Eq o) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Classes’
instance Eq Bool -- Defined in ‘GHC.Classes’
instance Eq Char -- Defined in ‘GHC.Classes’
instance Eq Double -- Defined in ‘GHC.Classes’
instance Eq Float -- Defined in ‘GHC.Classes’
instance Eq Int -- Defined in ‘GHC.Classes’
instance Eq Ordering -- Defined in ‘GHC.Classes’
instance Eq a => Eq (Solo a) -- Defined in ‘GHC.Classes’
instance Eq Word -- Defined in ‘GHC.Classes’
instance Eq a => Eq [a] -- Defined in ‘GHC.Classes’
instance Eq Integer -- Defined in ‘GHC.Num.Integer’
instance (Eq a, Eq b) => Eq (Either a b)
  -- Defined in ‘Data.Either’
instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Neg (Succ (Succ Zero)) == Pos (Succ (Succ Zero))
Neg (Succ (Succ Zero)) == Pos (Succ (Succ Zero))
False
ghci> Pos (Succ (Succ Zero)) == Pos (Succ (Succ Zero))
Pos (Succ (Succ Zero)) == Pos (Succ (Succ Zero))
True
ghci> Neg (Succ (Succ Zero)) == Neg (Succ (Succ Zero))
Neg (Succ (Succ Zero)) == Neg (Succ (Succ Zero))
True
ghci> Neg Zero == Pos Zero
Neg Zero == Pos Zero
True
ghci> Neg (Succ Zero) == Pos (Succ Zero)
Neg (Succ Zero) == Pos (Succ Zero)
False
ghci> Neg (Succ Zero) == Pos Zero
Neg (Succ Zero) == Pos Zero
False
ghci> :info Eq
:info Eq
type Eq :: * -> Constraint
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘GHC.Classes’
instance Eq Dow -- Defined at c06.hs:5:61
instance Eq Nat -- Defined at c06.hs:7:37
instance Eq Z -- Defined at c06.hs:11:10
instance Eq () -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b) => Eq (a, b) -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c) => Eq (a, b, c)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) =>
         Eq (a, b, c, d, e, f)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) =>
         Eq (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) =>
         Eq (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) =>
         Eq (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j) =>
         Eq (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n, Eq o) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Classes’
instance Eq Bool -- Defined in ‘GHC.Classes’
instance Eq Char -- Defined in ‘GHC.Classes’
instance Eq Double -- Defined in ‘GHC.Classes’
instance Eq Float -- Defined in ‘GHC.Classes’
instance Eq Int -- Defined in ‘GHC.Classes’
instance Eq Ordering -- Defined in ‘GHC.Classes’
instance Eq a => Eq (Solo a) -- Defined in ‘GHC.Classes’
instance Eq Word -- Defined in ‘GHC.Classes’
instance Eq a => Eq [a] -- Defined in ‘GHC.Classes’
instance Eq Integer -- Defined in ‘GHC.Num.Integer’
instance (Eq a, Eq b) => Eq (Either a b)
  -- Defined in ‘Data.Either’
instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’
ghci> :r
:r
Ok, one module loaded.
ghci> Neg (Succ Zero) /= Pos Zero
Neg (Succ Zero) /= Pos Zero
True
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:17:26: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘Nat’
    • In the first argument of ‘(/)’, namely ‘x’
      In the expression: x / y
      In an equation for ‘/=’: (/=) (Pos x) (Pos y) = x / y
   |
17 |   (/=) (Pos x) (Pos y) = x / y
   |                          ^

c06.hs:17:30: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘Nat’
    • In the second argument of ‘(/)’, namely ‘y’
      In the expression: x / y
      In an equation for ‘/=’: (/=) (Pos x) (Pos y) = x / y
   |
17 |   (/=) (Pos x) (Pos y) = x / y
   |                              ^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )
Ok, one module loaded.
ghci> Neg (Succ Zero) /= Pos Zero
Neg (Succ Zero) /= Pos Zero
True
ghci> Neg Zero /= Pos Zero
Neg Zero /= Pos Zero
False
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:11:10: warning: [-Wmissing-methods]
    • No explicit implementation for
        either ‘==’ or ‘/=’
    • In the instance declaration for ‘Eq Z’
   |
11 | instance Eq Z where
   |          ^^^^
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Mon
Mon

<interactive>:35:1: error:
    • No instance for (Show Dow) arising from a use of ‘print’
    • In a stmt of an interactive GHCi command: print it
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Mon
Mon
Mon
ghci> :i Show
:i Show
type Show :: * -> Constraint
class Show a where
  showsPrec :: Int -> a -> ShowS
  show :: a -> String
  showList :: [a] -> ShowS
  {-# MINIMAL showsPrec | show #-}
  	-- Defined in ‘GHC.Show’
instance Show Dow -- Defined at c06.hs:5:66
instance Show Double -- Defined in ‘GHC.Float’
instance Show Float -- Defined in ‘GHC.Float’
instance Show () -- Defined in ‘GHC.Show’
instance (Show a, Show b) => Show (a, b) -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c) => Show (a, b, c)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d) => Show (a, b, c, d)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e) =>
         Show (a, b, c, d, e)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f) =>
         Show (a, b, c, d, e, f)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f,
          Show g) =>
         Show (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h) =>
         Show (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i) =>
         Show (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j) =>
         Show (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k) =>
         Show (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l, Show m) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l, Show m, Show n) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Show’
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g,
          Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o) =>
         Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Show’
instance Show Bool -- Defined in ‘GHC.Show’
instance Show Char -- Defined in ‘GHC.Show’
instance Show Int -- Defined in ‘GHC.Show’
instance Show Integer -- Defined in ‘GHC.Show’
instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’
instance Show Ordering -- Defined in ‘GHC.Show’
instance Show GHC.Types.RuntimeRep -- Defined in ‘GHC.Show’
instance Show a => Show (Solo a) -- Defined in ‘GHC.Show’
instance Show Word -- Defined in ‘GHC.Show’
instance Show a => Show [a] -- Defined in ‘GHC.Show’
instance (Show a, Show b) => Show (Either a b)
  -- Defined in ‘Data.Either’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Mon
Mon
Luni
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:9:8: error:
    • Couldn't match expected type ‘a’ with actual type ‘Dow’
      ‘a’ is a rigid type variable bound by
        the type signature for:
          show :: forall a. a -> String
        at c06.hs:8:11-21
    • In the pattern: Mon
      In an equation for ‘show’: show Mon = "Luni"
      In the instance declaration for ‘Show Dow’
    • Relevant bindings include
        show :: a -> String (bound at c06.hs:9:3)
  |
9 |   show Mon = "Luni"
  |        ^^^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )
Ok, one module loaded.
ghci> :i Ord
:i Ord
type Ord :: * -> Constraint
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  {-# MINIMAL compare | (<=) #-}
  	-- Defined in ‘GHC.Classes’
instance Ord () -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b) => Ord (a, b) -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d, e)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) =>
         Ord (a, b, c, d, e, f)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) =>
         Ord (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g,
          Ord h) =>
         Ord (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i) =>
         Ord (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j) =>
         Ord (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Classes’
instance Ord Bool -- Defined in ‘GHC.Classes’
instance Ord Char -- Defined in ‘GHC.Classes’
instance Ord Double -- Defined in ‘GHC.Classes’
instance Ord Float -- Defined in ‘GHC.Classes’
instance Ord Int -- Defined in ‘GHC.Classes’
instance Ord Ordering -- Defined in ‘GHC.Classes’
instance Ord a => Ord (Solo a) -- Defined in ‘GHC.Classes’
instance Ord Word -- Defined in ‘GHC.Classes’
instance Ord a => Ord [a] -- Defined in ‘GHC.Classes’
instance Ord Integer -- Defined in ‘GHC.Num.Integer’
instance (Ord a, Ord b) => Ord (Either a b)
  -- Defined in ‘Data.Either’
instance Ord a => Ord (Maybe a) -- Defined in ‘GHC.Maybe’
ghci> :i Ordering
:i Ordering
type Ordering :: *
data Ordering = LT | EQ | GT
  	-- Defined in ‘GHC.Types’
instance Monoid Ordering -- Defined in ‘GHC.Base’
instance Semigroup Ordering -- Defined in ‘GHC.Base’
instance Bounded Ordering -- Defined in ‘GHC.Enum’
instance Enum Ordering -- Defined in ‘GHC.Enum’
instance Eq Ordering -- Defined in ‘GHC.Classes’
instance Ord Ordering -- Defined in ‘GHC.Classes’
instance Read Ordering -- Defined in ‘GHC.Read’
instance Show Ordering -- Defined in ‘GHC.Show’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Zero < Zero
Zero < Zero
False
ghci> Zero <= Zero
Zero <= Zero
True
ghci> Zero <= Succ (Succ Zero)
Zero <= Succ (Succ Zero)
True
ghci> Succ (Succ (Succ Zero)) <= Succ (Succ Zero)
Succ (Succ (Succ Zero)) <= Succ (Succ Zero)
False
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Neg (Succ (Succ Zero)) <= Pos (Succ Zero)
Neg (Succ (Succ Zero)) <= Pos (Succ Zero)
True
ghci> Pos (Succ (Succ Zero)) <= Pos (Succ Zero)
 Pos (Succ (Succ Zero)) <= Pos (Succ Zero)
False
ghci>  Pos (Succ (Succ Zero)) <= Pos (Succ (Succ (Succ Zero)))
 Pos (Succ (Succ Zero)) <= Pos (Succ (Succ (Succ Zero)))
True
ghci> Neg (Succ (Succ Zero)) <= Neg (Succ (Succ (Succ Zero)))
Neg (Succ (Succ Zero)) <= Neg (Succ (Succ (Succ Zero)))
True
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Succ Zero < Zero
Succ Zero < Zero
True
ghci> Succ (Succ Zero) < Zero
Succ (Succ Zero) < Zero
True
ghci> Neg Zero < Pos Zero
Neg Zero < Pos Zero
True
ghci> Neg (Succ (Succ Zero)) <= Neg (Succ (Succ (Succ Zero))):r
Neg (Succ (Succ Zero)) <= Neg (Succ (Succ (Succ Zero))):r

<interactive>:60:57: error: Variable not in scope: r :: [Z]
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Neg (Succ (Succ Zero)) <= Neg (Succ (Succ (Succ Zero)))
Neg (Succ (Succ Zero)) <= Neg (Succ (Succ (Succ Zero)))
True
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> Neg (Succ (Succ Zero)) <= Neg (Succ (Succ (Succ Zero)))
Neg (Succ (Succ Zero)) <= Neg (Succ (Succ (Succ Zero)))
False
ghci> Neg (Succ (Succ (Succ Zero))) <= Neg (Succ (Succ Zero))
Neg (Succ (Succ (Succ Zero))) <= Neg (Succ (Succ Zero))
True
ghci> Neg Zero <= Pos Zero
Neg Zero <= Pos Zero
True
ghci> Pos Zero <= Neg Zero
Pos Zero <= Neg Zero
True
ghci> :i Ord
:i Ord
type Ord :: * -> Constraint
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  {-# MINIMAL compare | (<=) #-}
  	-- Defined in ‘GHC.Classes’
instance Ord Nat -- Defined at c06.hs:17:42
instance Ord Z -- Defined at c06.hs:22:10
instance Ord () -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b) => Ord (a, b) -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d, e)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) =>
         Ord (a, b, c, d, e, f)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) =>
         Ord (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g,
          Ord h) =>
         Ord (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i) =>
         Ord (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j) =>
         Ord (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Classes’
instance Ord Bool -- Defined in ‘GHC.Classes’
instance Ord Char -- Defined in ‘GHC.Classes’
instance Ord Double -- Defined in ‘GHC.Classes’
instance Ord Float -- Defined in ‘GHC.Classes’
instance Ord Int -- Defined in ‘GHC.Classes’
instance Ord Ordering -- Defined in ‘GHC.Classes’
instance Ord a => Ord (Solo a) -- Defined in ‘GHC.Classes’
instance Ord Word -- Defined in ‘GHC.Classes’
instance Ord a => Ord [a] -- Defined in ‘GHC.Classes’
instance Ord Integer -- Defined in ‘GHC.Num.Integer’
instance (Ord a, Ord b) => Ord (Either a b)
  -- Defined in ‘Data.Either’
instance Ord a => Ord (Maybe a) -- Defined in ‘GHC.Maybe’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:22:10: error:
    • No instance for (Eq Z)
        arising from the superclasses of an instance declaration
    • In the instance declaration for ‘Ord Z’
   |
22 | instance Ord Z where
   |          ^^^^^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )
Ok, one module loaded.
ghci> :i Bounded
:i Bounded
type Bounded :: * -> Constraint
class Bounded a where
  minBound :: a
  maxBound :: a
  {-# MINIMAL minBound, maxBound #-}
  	-- Defined in ‘GHC.Enum’
instance Bounded () -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b) => Bounded (a, b)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c) => Bounded (a, b, c)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d) =>
         Bounded (a, b, c, d)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) =>
         Bounded (a, b, c, d, e)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f) =>
         Bounded (a, b, c, d, e, f)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f, Bounded g) =>
         Bounded (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f, Bounded g, Bounded h) =>
         Bounded (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f, Bounded g, Bounded h, Bounded i) =>
         Bounded (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f, Bounded g, Bounded h, Bounded i, Bounded j) =>
         Bounded (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f, Bounded g, Bounded h, Bounded i, Bounded j,
          Bounded k) =>
         Bounded (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
          Bounded l) =>
         Bounded (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
          Bounded l, Bounded m) =>
         Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
          Bounded l, Bounded m, Bounded n) =>
         Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Enum’
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e,
          Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k,
          Bounded l, Bounded m, Bounded n, Bounded o) =>
         Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Enum’
instance Bounded Bool -- Defined in ‘GHC.Enum’
instance Bounded Char -- Defined in ‘GHC.Enum’
instance Bounded Int -- Defined in ‘GHC.Enum’
instance Bounded Ordering -- Defined in ‘GHC.Enum’
instance Bounded a => Bounded (Solo a) -- Defined in ‘GHC.Enum’
instance Bounded Word -- Defined in ‘GHC.Enum’
ghci> minBound :: Bool
minBound :: Bool
False
ghci maxBound :: Bool
 maxBound :: Bool
True
ghci>  maxBound :: Int
 maxBound :: Int
9223372036854775807
ghci>  minBound :: Int
 minBound :: Int
-9223372036854775808
ghci> 2^63
2^63
9223372036854775808
ghci> minBound
minBound
()
ghci> minBound :: Word
minBound :: Word
0
ghci> maxBound :: Word
maxBound :: Word
18446744073709551615
ghci> 2^64
2^64
18446744073709551616
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> minBound :: Dow
minBound :: Dow
Luni
ghci> maxBound :: Dow
maxBound :: Dow
Duminica
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:17:47: error:
    • Can't make a derived instance of ‘Bounded Nat’:
        ‘Nat’ must be an enumeration type
        (an enumeration consists of one or more nullary, non-GADT constructors)
          or
        ‘Nat’ must have precisely one constructor
    • In the data declaration for ‘Nat’
   |
17 | data Nat = Zero | Succ Nat deriving (Eq, Ord, Bounded)
   |                                               ^^^^^^^
Failed, no modules loaded.
ghci> :i Enum
:i Enum
type Enum :: * -> Constraint
class Enum a where
  succ :: a -> a
  pred :: a -> a
  toEnum :: Int -> a
  fromEnum :: a -> Int
  enumFrom :: a -> [a]
  enumFromThen :: a -> a -> [a]
  enumFromTo :: a -> a -> [a]
  enumFromThenTo :: a -> a -> a -> [a]
  {-# MINIMAL toEnum, fromEnum #-}
  	-- Defined in ‘GHC.Enum’
instance Enum Double -- Defined in ‘GHC.Float’
instance Enum Float -- Defined in ‘GHC.Float’
instance Enum () -- Defined in ‘GHC.Enum’
instance Enum Bool -- Defined in ‘GHC.Enum’
instance Enum Char -- Defined in ‘GHC.Enum’
instance Enum Int -- Defined in ‘GHC.Enum’
instance Enum Integer -- Defined in ‘GHC.Enum’
instance Enum Ordering -- Defined in ‘GHC.Enum’
instance Enum a => Enum (Solo a) -- Defined in ‘GHC.Enum’
instance Enum Word -- Defined in ‘GHC.Enum’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )
Ok, one module loaded.
ghci> succ Mon
succ Mon
Marti
ghci> succ Sun
succ Sun
*** Exception: succ{Dow}: tried to take `succ' of last tag in enumeration
CallStack (from HasCallStack):
  error, called at c06.hs:5:75 in main:Main
ghci> pred Luni
pred Luni

<interactive>:89:6: error: Data constructor not in scope: Luni
ghci> pred Mon
pred Mon
*** Exception: pred{Dow}: tried to take `pred' of first tag in enumeration
CallStack (from HasCallStack):
  error, called at c06.hs:5:75 in main:Main
ghci> toEnum 0
toEnum 0
()
ghci> toEnum 0 :: Dow
toEnum 0 :: Dow
Luni
ghci> toEnum 3 :: Dow
toEnum 3 :: Dow
Joi
ghci> toEnum 6 :: Dow
toEnum 6 :: Dow
Duminica
ghci> toEnum 7 :: Dow
toEnum 7 :: Dow
*** Exception: toEnum{Dow}: tag (7) is outside of enumeration's range (0,6)
CallStack (from HasCallStack):
  error, called at c06.hs:5:75 in main:Main
ghci> enumFromThen Mon Thu
enumFromThen Mon Thu
[Luni,Joi,Duminica]
ghci> enumFromThen Mon Tue
enumFromThen Mon Tue
[Luni,Marti,Miercuri,Joi,Vineri,Sambata,Duminica]
ghci> enumFromThen Mon Wed
enumFromThen Mon Wed
[Luni,Miercuri,Vineri,Duminica]
ghci> [0..10]
[0..10]
[0,1,2,3,4,5,6,7,8,9,10]
ghci> [Luni..Miercuri]
[Luni..Miercuri]

<interactive>:100:2: error:
    Not in scope: ‘Luni..’
    NB: no module named ‘Luni’ is imported.

<interactive>:100:2: error:
    A section must be enclosed in parentheses thus: (Luni.. Miercuri)
ghci> [Luni..]
[Luni..]

<interactive>:101:8: error: parse error on input ‘]’
ghci> [Mon..]
[Mon..]

<interactive>:102:7: error: parse error on input ‘]’
ghci> [1..10]
[1..10]
[1,2,3,4,5,6,7,8,9,10]
ghci> :i (..)
:i (..)

<interactive>:1:2: error: parse error on input ‘..’
ghci> enumFromThenTo 1 2 10
enumFromThenTo 1 2 10
[1,2,3,4,5,6,7,8,9,10]
ghci> [1,2..10]
[1,2..10]
[1,2,3,4,5,6,7,8,9,10]
ghci> fromEnum Wed
fromEnum Wed
2
ghci> :i Bool
:i Bool
type Bool :: *
data Bool = False | True
  	-- Defined in ‘GHC.Types’
instance Bounded Bool -- Defined in ‘GHC.Enum’
instance Enum Bool -- Defined in ‘GHC.Enum’
instance Eq Bool -- Defined in ‘GHC.Classes’
instance Ord Bool -- Defined in ‘GHC.Classes’
instance Read Bool -- Defined in ‘GHC.Read’
instance Show Bool -- Defined in ‘GHC.Show’
ghci> :i Read
:i Read
type Read :: * -> Constraint
class Read a where
  readsPrec :: Int -> ReadS a
  readList :: ReadS [a]
  GHC.Read.readPrec :: Text.ParserCombinators.ReadPrec.ReadPrec a
  GHC.Read.readListPrec :: Text.ParserCombinators.ReadPrec.ReadPrec
                             [a]
  {-# MINIMAL readsPrec | readPrec #-}
  	-- Defined in ‘GHC.Read’
instance (Read a, Read b) => Read (Either a b)
  -- Defined in ‘Data.Either’
instance Read () -- Defined in ‘GHC.Read’
instance (Read a, Read b) => Read (a, b) -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c) => Read (a, b, c)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d) => Read (a, b, c, d)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e) =>
         Read (a, b, c, d, e)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f) =>
         Read (a, b, c, d, e, f)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f,
          Read g) =>
         Read (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g,
          Read h) =>
         Read (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g,
          Read h, Read i) =>
         Read (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g,
          Read h, Read i, Read j) =>
         Read (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g,
          Read h, Read i, Read j, Read k) =>
         Read (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g,
          Read h, Read i, Read j, Read k, Read l) =>
         Read (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g,
          Read h, Read i, Read j, Read k, Read l, Read m) =>
         Read (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g,
          Read h, Read i, Read j, Read k, Read l, Read m, Read n) =>
         Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Read’
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g,
          Read h, Read i, Read j, Read k, Read l, Read m, Read n, Read o) =>
         Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Read’
instance Read Bool -- Defined in ‘GHC.Read’
instance Read Char -- Defined in ‘GHC.Read’
instance Read Double -- Defined in ‘GHC.Read’
instance Read Float -- Defined in ‘GHC.Read’
instance Read Int -- Defined in ‘GHC.Read’
instance Read Integer -- Defined in ‘GHC.Read’
instance Read a => Read (Maybe a) -- Defined in ‘GHC.Read’
instance Read Ordering -- Defined in ‘GHC.Read’
instance Read a => Read (Solo a) -- Defined in ‘GHC.Read’
instance Read Word -- Defined in ‘GHC.Read’
instance Read a => Read [a] -- Defined in ‘GHC.Read’
ghci> :i ReadS
:i ReadS
type ReadS :: * -> *
type ReadS a = String -> [(a, String)]
  	-- Defined in ‘Text.ParserCombinators.ReadP’
ghci> :i Int
:i Int
type Int :: *
data Int = GHC.Types.I# GHC.Prim.Int#
  	-- Defined in ‘GHC.Types’
instance Integral Int -- Defined in ‘GHC.Real’
instance Num Int -- Defined in ‘GHC.Num’
instance Real Int -- Defined in ‘GHC.Real’
instance Bounded Int -- Defined in ‘GHC.Enum’
instance Enum Int -- Defined in ‘GHC.Enum’
instance Eq Int -- Defined in ‘GHC.Classes’
instance Ord Int -- Defined in ‘GHC.Classes’
instance Read Int -- Defined in ‘GHC.Read’
instance Show Int -- Defined in ‘GHC.Show’
ghci> :i Integral
:i Integral
type Integral :: * -> Constraint
class (Real a, Enum a) => Integral a where
  quot :: a -> a -> a
  rem :: a -> a -> a
  div :: a -> a -> a
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer
  {-# MINIMAL quotRem, toInteger #-}
  	-- Defined in ‘GHC.Real’
instance Integral Int -- Defined in ‘GHC.Real’
instance Integral Integer -- Defined in ‘GHC.Real’
instance Integral Word -- Defined in ‘GHC.Real’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:28:47: error:
    • Can't make a derived instance of ‘Integral Nat’:
        ‘Integral’ is not a stock derivable class (Eq, Show, etc.)
    • In the data declaration for ‘Nat’
    Suggested fix: Perhaps you intended to use DeriveAnyClass
   |
28 | data Nat = Zero | Succ Nat deriving (Eq, Ord, Integral) -- , Bounded)
   |                                               ^^^^^^^^
Failed, no modules loaded.
ghci> :i Real
:i Real
type Real :: * -> Constraint
class (Num a, Ord a) => Real a where
  toRational :: a -> Rational
  {-# MINIMAL toRational #-}
  	-- Defined in ‘GHC.Real’
instance Real Double -- Defined in ‘GHC.Float’
instance Real Float -- Defined in ‘GHC.Float’
instance Real Int -- Defined in ‘GHC.Real’
instance Real Integer -- Defined in ‘GHC.Real’
instance Real Word -- Defined in ‘GHC.Real’
ghci> :i Rational
:i Rational
type Rational :: *
type Rational = GHC.Real.Ratio Integer
  	-- Defined in ‘GHC.Real’
ghci> :i Ratio
:i Ratio

<interactive>:1:1: error: Not in scope: ‘Ratio’
ghci> :i GHC.Real.Ratio
:i GHC.Real.Ratio
type GHC.Real.Ratio :: * -> *
data GHC.Real.Ratio a = !a GHC.Real.:% !a
  	-- Defined in ‘GHC.Real’
instance Integral a => Fractional (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Integral a => RealFrac (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Integral a => Num (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Integral a => Real (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Integral a => Enum (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Eq a => Eq (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance Integral a => Ord (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance (Integral a, Read a) => Read (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Read’
instance Show a => Show (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )

c06.hs:33:23: error:
    Ambiguous occurrence ‘fromInteger’
    It could refer to
       either ‘Prelude.fromInteger’,
              imported from ‘Prelude’ at c06.hs:1:1
              (and originally defined in ‘GHC.Num’)
           or ‘Main.fromInteger’, defined at c06.hs:32:1
   |
33 | fromInteger x = Succ (fromInteger (x - 1))
   |                       ^^^^^^^^^^^

c06.hs:36:32: error:
    Not in scope: data constructor ‘GHC.Real.:%’
    NB: no module named ‘GHC.Real’ is imported.
   |
36 |   toRational x = (toInteger x) GHC.Real.:% 1
   |                                ^^^^^^^^^^^

c06.hs:41:18: error:
    Ambiguous occurrence ‘fromInteger’
    It could refer to
       either ‘Prelude.fromInteger’,
              imported from ‘Prelude’ at c06.hs:1:1
              (and originally defined in ‘GHC.Num’)
           or ‘Main.fromInteger’, defined at c06.hs:32:1
   |
41 |   quotRem x y = (fromInteger (quot (toInteger x) (toInteger y)),
   |                  ^^^^^^^^^^^

c06.hs:42:18: error:
    Ambiguous occurrence ‘fromInteger’
    It could refer to
       either ‘Prelude.fromInteger’,
              imported from ‘Prelude’ at c06.hs:1:1
              (and originally defined in ‘GHC.Num’)
           or ‘Main.fromInteger’, defined at c06.hs:32:1
   |
42 |                  fromInteger (rem (toInteger x) (toInteger y)))
   |                  ^^^^^^^^^^^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )

c06.hs:36:32: error:
    Not in scope: data constructor ‘GHC.Real.:%’
    NB: no module named ‘GHC.Real’ is imported.
   |
36 |   toRational x = (toInteger x) GHC.Real.:% 1
   |                                ^^^^^^^^^^^
Failed, no modules loaded.
ghci> :i Rational
:i Rational
type Rational :: *
type Rational = GHC.Real.Ratio Integer
  	-- Defined in ‘GHC.Real’
ghci> :i GHC.Real.Ratio
:i GHC.Real.Ratio
type GHC.Real.Ratio :: * -> *
data GHC.Real.Ratio a = !a GHC.Real.:% !a
  	-- Defined in ‘GHC.Real’
instance Integral a => Fractional (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Integral a => RealFrac (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Integral a => Num (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Integral a => Real (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Integral a => Enum (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance Eq a => Eq (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance Integral a => Ord (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Real’
instance (Integral a, Read a) => Read (GHC.Real.Ratio a)
  -- Defined in ‘GHC.Read’
instance Show a => Show (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )

c06.hs:35:10: error:
    • No instance for (Num Nat)
        arising from the superclasses of an instance declaration
    • In the instance declaration for ‘Real Nat’
   |
35 | instance Real Nat where
   |          ^^^^^^^^

c06.hs:38:10: error:
    • No instance for (Enum Nat)
        arising from the superclasses of an instance declaration
    • In the instance declaration for ‘Integral Nat’
   |
38 | instance Integral Nat where
   |          ^^^^^^^^^^^^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )

c06.hs:28:47: error:
    • Can't make a derived instance of ‘Enum Nat’:
        ‘Nat’ must be an enumeration type
        (an enumeration consists of one or more nullary, non-GADT constructors)
    • In the data declaration for ‘Nat’
   |
28 | data Nat = Zero | Succ Nat deriving (Eq, Ord, Enum) -- , Bounded)
   |                                               ^^^^
Failed, no modules loaded.
ghci> :i Real
:i Real
type Real :: * -> Constraint
class (Num a, Ord a) => Real a where
  toRational :: a -> Rational
  {-# MINIMAL toRational #-}
  	-- Defined in ‘GHC.Real’
instance Real Double -- Defined in ‘GHC.Float’
instance Real Float -- Defined in ‘GHC.Float’
instance Real Int -- Defined in ‘GHC.Real’
instance Real Integer -- Defined in ‘GHC.Real’
instance Real Word -- Defined in ‘GHC.Real’
ghci> :i Integral
:i Integral
type Integral :: * -> Constraint
class (Real a, Enum a) => Integral a where
  quot :: a -> a -> a
  rem :: a -> a -> a
  div :: a -> a -> a
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer
  {-# MINIMAL quotRem, toInteger #-}
  	-- Defined in ‘GHC.Real’
instance Integral Int -- Defined in ‘GHC.Real’
instance Integral Integer -- Defined in ‘GHC.Real’
instance Integral Word -- Defined in ‘GHC.Real’
ghci> :i Enum
:i Enum
type Enum :: * -> Constraint
class Enum a where
  succ :: a -> a
  pred :: a -> a
  toEnum :: Int -> a
  fromEnum :: a -> Int
  enumFrom :: a -> [a]
  enumFromThen :: a -> a -> [a]
  enumFromTo :: a -> a -> [a]
  enumFromThenTo :: a -> a -> a -> [a]
  {-# MINIMAL toEnum, fromEnum #-}
  	-- Defined in ‘GHC.Enum’
instance Enum Double -- Defined in ‘GHC.Float’
instance Enum Float -- Defined in ‘GHC.Float’
instance Enum () -- Defined in ‘GHC.Enum’
instance Enum Bool -- Defined in ‘GHC.Enum’
instance Enum Char -- Defined in ‘GHC.Enum’
instance Enum Int -- Defined in ‘GHC.Enum’
instance Enum Integer -- Defined in ‘GHC.Enum’
instance Enum Ordering -- Defined in ‘GHC.Enum’
instance Enum a => Enum (Solo a) -- Defined in ‘GHC.Enum’
instance Enum Word -- Defined in ‘GHC.Enum’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )

c06.hs:41:10: error:
    • No instance for (Num Nat)
        arising from the superclasses of an instance declaration
    • In the instance declaration for ‘Real Nat’
   |
41 | instance Real Nat where
   |          ^^^^^^^^
Failed, no modules loaded.
ghci> :i Real
:i Real
type Real :: * -> Constraint
class (Num a, Ord a) => Real a where
  toRational :: a -> Rational
  {-# MINIMAL toRational #-}
  	-- Defined in ‘GHC.Real’
instance Real Double -- Defined in ‘GHC.Float’
instance Real Float -- Defined in ‘GHC.Float’
instance Real Int -- Defined in ‘GHC.Real’
instance Real Integer -- Defined in ‘GHC.Real’
instance Real Word -- Defined in ‘GHC.Real’
ghci> :i Num
:i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num Double -- Defined in ‘GHC.Float’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Word -- Defined in ‘GHC.Num’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )
Ok, one module loaded.
ghci> (Succ (Succ Zero)) + (Succ Zero)
(Succ (Succ Zero)) + (Succ Zero)

<interactive>:131:1: error:
    • No instance for (Show Nat) arising from a use of ‘print’
    • In a stmt of an interactive GHCi command: print it
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> (Succ (Succ Zero)) + (Succ Zero)
(Succ (Succ Zero)) + (Succ Zero)
Succ (Succ (Succ Zero))
ghci> :i Int
:i Int
type Int :: *
data Int = GHC.Types.I# GHC.Prim.Int#
  	-- Defined in ‘GHC.Types’
instance Integral Int -- Defined in ‘GHC.Real’
instance Num Int -- Defined in ‘GHC.Num’
instance Real Int -- Defined in ‘GHC.Real’
instance Bounded Int -- Defined in ‘GHC.Enum’
instance Enum Int -- Defined in ‘GHC.Enum’
instance Eq Int -- Defined in ‘GHC.Classes’
instance Ord Int -- Defined in ‘GHC.Classes’
instance Read Int -- Defined in ‘GHC.Read’
instance Show Int -- Defined in ‘GHC.Show’
ghci> :i Integral
:i Integral
type Integral :: * -> Constraint
class (Real a, Enum a) => Integral a where
  quot :: a -> a -> a
  rem :: a -> a -> a
  div :: a -> a -> a
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer
  {-# MINIMAL quotRem, toInteger #-}
  	-- Defined in ‘GHC.Real’
instance Integral Nat -- Defined at c06.hs:56:10
instance Integral Int -- Defined in ‘GHC.Real’
instance Integral Integer -- Defined in ‘GHC.Real’
instance Integral Word -- Defined in ‘GHC.Real’
ghci> :i Real
:i Real
type Real :: * -> Constraint
class (Num a, Ord a) => Real a where
  toRational :: a -> Rational
  {-# MINIMAL toRational #-}
  	-- Defined in ‘GHC.Real’
instance Real Nat -- Defined at c06.hs:53:10
instance Real Double -- Defined in ‘GHC.Float’
instance Real Float -- Defined in ‘GHC.Float’
instance Real Int -- Defined in ‘GHC.Real’
instance Real Integer -- Defined in ‘GHC.Real’
instance Real Word -- Defined in ‘GHC.Real’
ghci> :i Num
:i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num Nat -- Defined at c06.hs:31:10
instance Num Double -- Defined in ‘GHC.Float’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Word -- Defined in ‘GHC.Num’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:95:10: warning: [-Wmissing-methods]
    • No explicit implementation for
        ‘neegal’
    • In the instance declaration for ‘MyEq Nat’
   |
95 | instance MyEq Nat where
   |          ^^^^^^^^
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> egal (Succ (Succ Zero)) (Succ Zero)
egal (Succ (Succ Zero)) (Succ Zero)
False
ghci> egal (Succ (Succ Zero)) (Succ (Succ Zero))
egal (Succ (Succ Zero)) (Succ (Succ Zero))
True
ghci> :i MyEq
:i MyEq
type MyEq :: * -> Constraint
class MyEq a where
  egal :: a -> a -> Bool
  neegal :: a -> a -> Bool
  {-# MINIMAL egal, neegal #-}
  	-- Defined at c06.hs:91:1
instance MyEq Nat -- Defined at c06.hs:95:10
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :i MyEq
:i MyEq
type MyEq :: * -> Constraint
class MyEq a where
  egal :: a -> a -> Bool
  neegal :: a -> a -> Bool
  {-# MINIMAL egal #-}
  	-- Defined at c06.hs:91:1
instance MyEq Nat -- Defined at c06.hs:96:10
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :i MyEq
:i MyEq
type MyEq :: * -> Constraint
class MyEq a where
  egal :: a -> a -> Bool
  neegal :: a -> a -> Bool
  	-- Defined at c06.hs:91:1
instance MyEq Nat -- Defined at c06.hs:97:10
ghci> :i MyEq
:i MyEq
type MyEq :: * -> Constraint
class MyEq a where
  egal :: a -> a -> Bool
  neegal :: a -> a -> Bool
  	-- Defined at c06.hs:91:1
instance MyEq Nat -- Defined at c06.hs:97:10
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :i MyEq
:i MyEq
type MyEq :: * -> Constraint
class MyEq a where
  egal :: a -> a -> Bool
  neegal :: a -> a -> Bool
  {-# MINIMAL egal | neegal #-}
  	-- Defined at c06.hs:91:1
instance MyEq Nat -- Defined at c06.hs:98:10
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> neegal (Succ (Succ Zero)) (Succ (Succ Zero))
neegal (Succ (Succ Zero)) (Succ (Succ Zero))
False
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:98:10: warning: [-Wmissing-methods]
    • No explicit implementation for
        either ‘egal’ or ‘neegal’
    • In the instance declaration for ‘MyEq Nat’
   |
98 | instance MyEq Nat where
   |          ^^^^^^^^
Ok, one module loaded.
ghci> neegal (Succ (Succ Zero)) (Succ (Succ Zero))
neegal (Succ (Succ Zero)) (Succ (Succ Zero))




*** Exception: stack overflow
ghci> 
ghci> 
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:98:10: warning: [-Wmissing-methods]
    • No explicit implementation for
        either ‘egal’ or ‘neegal’
    • In the instance declaration for ‘MyEq Nat’
   |
98 | instance MyEq Nat where
   |          ^^^^^^^^
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :r
:r
Ok, one module loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> :t True
:t True
True :: Bool
ghci> :k Bool
:k Bool
Bool :: *
ghci> :k Nat
:k Nat
Nat :: *
ghci> :k Integer
:k Integer
Integer :: *
ghci> :i Maybe
:i Maybe
type Maybe :: * -> *
data Maybe a = Nothing | Just a
  	-- Defined in ‘GHC.Maybe’
instance Traversable Maybe -- Defined in ‘Data.Traversable’
instance Foldable Maybe -- Defined in ‘Data.Foldable’
instance Semigroup a => Monoid (Maybe a) -- Defined in ‘GHC.Base’
instance Semigroup a => Semigroup (Maybe a)
  -- Defined in ‘GHC.Base’
instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’
instance Ord a => Ord (Maybe a) -- Defined in ‘GHC.Maybe’
instance Read a => Read (Maybe a) -- Defined in ‘GHC.Read’
instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance MonadFail Maybe -- Defined in ‘Control.Monad.Fail’
instance Monad Maybe -- Defined in ‘GHC.Base’
ghci> :k Maybe
:k Maybe
Maybe :: * -> *
ghci> :k (Maybe Bool)
:k (Maybe Bool)
(Maybe Bool) :: *
ghci> :i Eq
:i Eq
type Eq :: * -> Constraint
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘GHC.Classes’
instance Eq Dow -- Defined at c06.hs:5:62
instance Eq Nat -- Defined at c06.hs:28:38
instance Eq Unit -- Defined at c06.hs:109:31
instance Eq Z -- Defined at c06.hs:74:10
instance Eq () -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b) => Eq (a, b) -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c) => Eq (a, b, c)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (a, b, c, d, e)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) =>
         Eq (a, b, c, d, e, f)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) =>
         Eq (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) =>
         Eq (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) =>
         Eq (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j) =>
         Eq (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Classes’
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i,
          Eq j, Eq k, Eq l, Eq m, Eq n, Eq o) =>
         Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Classes’
instance Eq Bool -- Defined in ‘GHC.Classes’
instance Eq Char -- Defined in ‘GHC.Classes’
instance Eq Double -- Defined in ‘GHC.Classes’
instance Eq Float -- Defined in ‘GHC.Classes’
instance Eq Int -- Defined in ‘GHC.Classes’
instance Eq Ordering -- Defined in ‘GHC.Classes’
instance Eq a => Eq (Solo a) -- Defined in ‘GHC.Classes’
instance Eq Word -- Defined in ‘GHC.Classes’
instance Eq a => Eq [a] -- Defined in ‘GHC.Classes’
instance Eq Integer -- Defined in ‘GHC.Num.Integer’
instance (Eq a, Eq b) => Eq (Either a b)
  -- Defined in ‘Data.Either’
instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’
ghci> :i Ord
:i Ord
type Ord :: * -> Constraint
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  {-# MINIMAL compare | (<=) #-}
  	-- Defined in ‘GHC.Classes’
instance Ord Nat -- Defined at c06.hs:28:42
instance Ord Unit -- Defined at c06.hs:109:35
instance Ord Z -- Defined at c06.hs:68:10
instance Ord () -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b) => Ord (a, b) -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d, e)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) =>
         Ord (a, b, c, d, e, f)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) =>
         Ord (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g,
          Ord h) =>
         Ord (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i) =>
         Ord (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j) =>
         Ord (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Classes’
instance Ord Bool -- Defined in ‘GHC.Classes’
instance Ord Char -- Defined in ‘GHC.Classes’
instance Ord Double -- Defined in ‘GHC.Classes’
instance Ord Float -- Defined in ‘GHC.Classes’
instance Ord Int -- Defined in ‘GHC.Classes’
instance Ord Ordering -- Defined in ‘GHC.Classes’
instance Ord a => Ord (Solo a) -- Defined in ‘GHC.Classes’
instance Ord Word -- Defined in ‘GHC.Classes’
instance Ord a => Ord [a] -- Defined in ‘GHC.Classes’
instance Ord Integer -- Defined in ‘GHC.Num.Integer’
instance (Ord a, Ord b) => Ord (Either a b)
  -- Defined in ‘Data.Either’
instance Ord a => Ord (Maybe a) -- Defined in ‘GHC.Maybe’
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]
Ok, one module loaded.
ghci> sort [5,8,6,7,4,3,2,5,7,9]
sort [5,8,6,7,4,3,2,5,7,9]
[2,3,4,5,5,6,7,7,8,9]
ghci> sort ["asdf", "thhtr", "213213", "QQWQwqw"]
sort ["asdf", "thhtr", "213213", "QQWQwqw"]

<interactive>:174:7: error:
    • Couldn't match type ‘[Char]’ with ‘Int’
      Expected: Int
        Actual: String
    • In the expression: "asdf"
      In the first argument of ‘sort’, namely
        ‘["asdf", "thhtr", "213213", "QQWQwqw"]’
      In the expression: sort ["asdf", "thhtr", "213213", "QQWQwqw"]

<interactive>:174:15: error:
    • Couldn't match type ‘[Char]’ with ‘Int’
      Expected: Int
        Actual: String
    • In the expression: "thhtr"
      In the first argument of ‘sort’, namely
        ‘["asdf", "thhtr", "213213", "QQWQwqw"]’
      In the expression: sort ["asdf", "thhtr", "213213", "QQWQwqw"]

<interactive>:174:24: error:
    • Couldn't match type ‘[Char]’ with ‘Int’
      Expected: Int
        Actual: String
    • In the expression: "213213"
      In the first argument of ‘sort’, namely
        ‘["asdf", "thhtr", "213213", "QQWQwqw"]’
      In the expression: sort ["asdf", "thhtr", "213213", "QQWQwqw"]

<interactive>:174:34: error:
    • Couldn't match type ‘[Char]’ with ‘Int’
      Expected: Int
        Actual: String
    • In the expression: "QQWQwqw"
      In the first argument of ‘sort’, namely
        ‘["asdf", "thhtr", "213213", "QQWQwqw"]’
      In the expression: sort ["asdf", "thhtr", "213213", "QQWQwqw"]
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted ) [Source file changed]

c06.hs:155:30: error:
    • No instance for (Ord a) arising from a use of ‘<=’
      Possible fix:
        add (Ord a) to the context of
          the type signature for:
            sort :: forall a. [a] -> [a]
    • In the expression: (<=)
      In the first argument of ‘filter’, namely ‘(<= x)’
      In the first argument of ‘sort’, namely ‘(filter (<= x) xs)’
    |
155 | sort (x:xs) = (sort (filter (<=x) xs)) ++ [x] ++ (sort (filter (>x) xs))
    |                              ^^
Failed, no modules loaded.
ghci> :r
:r
[1 of 2] Compiling Main             ( c06.hs, interpreted )
Ok, one module loaded.
ghci> sort ["asdf", "thhtr", "213213", "QQWQwqw"]
sort ["asdf", "thhtr", "213213", "QQWQwqw"]
["213213","QQWQwqw","asdf","thhtr"]
ghci> sort [5,8,6,7,4,3,2,5,7,9]
sort [5,8,6,7,4,3,2,5,7,9]
[2,3,4,5,5,6,7,7,8,9]
ghci> :t sort
:t sort
sort :: Ord a => [a] -> [a]
ghci> sort ["asdf10", "asdf100"]
sort ["asdf10", "asdf100"]
["asdf10","asdf100"]
ghci> sort ["asdf20", "asdf100"]
sort ["asdf20", "asdf100"]
["asdf100","asdf20"]
ghci> :i Functor
:i Functor
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  (<$) :: a -> f b -> f a
  {-# MINIMAL fmap #-}
  	-- Defined in ‘GHC.Base’
instance Functor ((,) a) -- Defined in ‘GHC.Base’
instance Functor ((,,) a b) -- Defined in ‘GHC.Base’
instance Functor ((,,,) a b c) -- Defined in ‘GHC.Base’
instance Functor ((->) r) -- Defined in ‘GHC.Base’
instance Functor IO -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Functor Solo -- Defined in ‘GHC.Base’
instance Functor [] -- Defined in ‘GHC.Base’
instance Functor (Either a) -- Defined in ‘Data.Either’
ghci> :k Maybe
:k Maybe
Maybe :: * -> *
ghci> fmap :: (a -> b) -> Maybe a -> Maybe b
fmap :: (a -> b) -> Maybe a -> Maybe b

<interactive>:184:1: error:
    • No instance for (Show ((a0 -> b0) -> Maybe a0 -> Maybe b0))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
ghci> :t fmap :: (a -> b) -> Maybe a -> Maybe b
:t fmap :: (a -> b) -> Maybe a -> Maybe b
fmap :: (a -> b) -> Maybe a -> Maybe b
  :: (a -> b) -> Maybe a -> Maybe b
ghci> :i Either
:i Either
type Either :: * -> * -> *
data Either a b = Left a | Right b
  	-- Defined in ‘Data.Either’
instance Traversable (Either a) -- Defined in ‘Data.Traversable’
instance Foldable (Either a) -- Defined in ‘Data.Foldable’
instance Semigroup (Either a b) -- Defined in ‘Data.Either’
instance (Eq a, Eq b) => Eq (Either a b)
  -- Defined in ‘Data.Either’
instance (Ord a, Ord b) => Ord (Either a b)
  -- Defined in ‘Data.Either’
instance (Read a, Read b) => Read (Either a b)
  -- Defined in ‘Data.Either’
instance (Show a, Show b) => Show (Either a b)
  -- Defined in ‘Data.Either’
instance Applicative (Either e) -- Defined in ‘Data.Either’
instance Functor (Either a) -- Defined in ‘Data.Either’
instance Monad (Either e) -- Defined in ‘Data.Either’
ghci> fmap :: (a -> b) -> Maybe a -> Maybe b
fmap :: (a -> b) -> Maybe a -> Maybe b

<interactive>:187:1: error:
    • No instance for (Show ((a0 -> b0) -> Maybe a0 -> Maybe b0))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
ghci> :t fmap :: (a -> b) -> Maybe a -> Maybe b
:t fmap :: (a -> b) -> Maybe a -> Maybe b
fmap :: (a -> b) -> Maybe a -> Maybe b
  :: (a -> b) -> Maybe a -> Maybe b
ghci> fmap (+7) (Just 10)
fmap (+7) (Just 10)
Just 17
ghci> fmap (+7) Nothing
fmap (+7) Nothing
Nothing
ghci> fmap (+7) (Right 10)
 fmap (+7) (Right 10)
Right 17
ghci>  fmap (+7) (Left 10)
 fmap (+7) (Left 10)
Left 10
ghci>  fmap (+7) (Left "impartire la 0")
 fmap (+7) (Left "impartire la 0")
Left "impartire la 0"
ghci>  fmap (+7) (Right 12)
 fmap (+7) (Right 12)
Right 19
ghci> :i Functor
:i Functor
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  (<$) :: a -> f b -> f a
  {-# MINIMAL fmap #-}
  	-- Defined in ‘GHC.Base’
instance Functor ((,) a) -- Defined in ‘GHC.Base’
instance Functor ((,,) a b) -- Defined in ‘GHC.Base’
instance Functor ((,,,) a b c) -- Defined in ‘GHC.Base’
instance Functor ((->) r) -- Defined in ‘GHC.Base’
instance Functor IO -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Functor Solo -- Defined in ‘GHC.Base’
instance Functor [] -- Defined in ‘GHC.Base’
instance Functor (Either a) -- Defined in ‘Data.Either’
ghci> 10 <$ Nothing
10 <$ Nothing
Nothing
ghci> 10 <$ Just 20
10 <$ Just 20
Just 10
ghci> :i Functor
:i Functor
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  (<$) :: a -> f b -> f a
  {-# MINIMAL fmap #-}
  	-- Defined in ‘GHC.Base’
instance Functor ((,) a) -- Defined in ‘GHC.Base’
instance Functor ((,,) a b) -- Defined in ‘GHC.Base’
instance Functor ((,,,) a b c) -- Defined in ‘GHC.Base’
instance Functor ((->) r) -- Defined in ‘GHC.Base’
instance Functor IO -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Functor Solo -- Defined in ‘GHC.Base’
instance Functor [] -- Defined in ‘GHC.Base’
instance Functor (Either a) -- Defined in ‘Data.Either’
ghci> fmap (+7) [10, 20, 30]
fmap (+7) [10, 20, 30]
[17,27,37]
ghci> map (+7) [10, 20, 30]
map (+7) [10, 20, 30]
[17,27,37]
ghci> fmap (+7) (Just 10)
fmap (+7) (Just 10)
Just 17
ghci> fmap (-15) (fmap (+7) (Just 10))
fmap (-15) (fmap (+7) (Just 10))

<interactive>:202:1: error:
    • Could not deduce (Num a0)
      from the context: (Num a, Num (a -> b))
        bound by the inferred type for ‘it’:
                   forall {a} {b}. (Num a, Num (a -> b)) => Maybe b
        at <interactive>:202:1-32
      The type variable ‘a0’ is ambiguous
      Potentially matching instances:
        instance Num Nat -- Defined at c06.hs:33:10
        instance Num Integer -- Defined in ‘GHC.Num’
        ...plus four others
        ...plus 17 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the ambiguity check for the inferred type for ‘it’
      To defer the ambiguity check to use sites, enable AllowAmbiguousTypes
      When checking the inferred type
        it :: forall {a} {b}. (Num a, Num (a -> b)) => Maybe b
ghci> fmap (+15) (fmap (+7) (Just 10))
fmap (+15) (fmap (+7) (Just 10))
Just 32
ghci> fmap (*15) (fmap (+7) Nothing)
fmap (*15) (fmap (+7) (Just 10))
Just 255
ghci> 17 * 15
17 * 15
255
ghci> fmap (*15) (fmap (+7) Nothing)
fmap (*15) (fmap (+7) Nothing)
Nothing
ghci> :t fmap
:t fmap
fmap :: Functor f => (a -> b) -> f a -> f b
ghci> :t foldl
:t foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
ghci> foldl (+) 0 [ 1, 2, 3, 4 ]
foldl (+) 0 [ 1, 2, 3, 4 ]
10
ghci> :i Foldable
:i Foldable
type Foldable :: (* -> *) -> Constraint
class Foldable t where
  Data.Foldable.fold :: Monoid m => t m -> m
  foldMap :: Monoid m => (a -> m) -> t a -> m
  Data.Foldable.foldMap' :: Monoid m => (a -> m) -> t a -> m
  foldr :: (a -> b -> b) -> b -> t a -> b
  Data.Foldable.foldr' :: (a -> b -> b) -> b -> t a -> b
  foldl :: (b -> a -> b) -> b -> t a -> b
  Data.Foldable.foldl' :: (b -> a -> b) -> b -> t a -> b
  foldr1 :: (a -> a -> a) -> t a -> a
  foldl1 :: (a -> a -> a) -> t a -> a
  Data.Foldable.toList :: t a -> [a]
  null :: t a -> Bool
  length :: t a -> Int
  elem :: Eq a => a -> t a -> Bool
  maximum :: Ord a => t a -> a
  minimum :: Ord a => t a -> a
  sum :: Num a => t a -> a
  product :: Num a => t a -> a
  {-# MINIMAL foldMap | foldr #-}
  	-- Defined in ‘Data.Foldable’
instance Foldable ((,) a) -- Defined in ‘Data.Foldable’
instance Foldable (Either a) -- Defined in ‘Data.Foldable’
instance Foldable Maybe -- Defined in ‘Data.Foldable’
instance Foldable Solo -- Defined in ‘Data.Foldable’
instance Foldable [] -- Defined in ‘Data.Foldable’
ghci> :i Monoid
:i Monoid
type Monoid :: * -> Constraint
class Semigroup a => Monoid a where
  mempty :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
  {-# MINIMAL mempty #-}
  	-- Defined in ‘GHC.Base’
instance Monoid () -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b) => Monoid (a, b)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c, Monoid d) =>
         Monoid (a, b, c, d)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
         Monoid (a, b, c, d, e)
  -- Defined in ‘GHC.Base’
instance Monoid b => Monoid (a -> b) -- Defined in ‘GHC.Base’
instance Monoid a => Monoid (IO a) -- Defined in ‘GHC.Base’
instance Semigroup a => Monoid (Maybe a) -- Defined in ‘GHC.Base’
instance Monoid Ordering -- Defined in ‘GHC.Base’
instance Monoid a => Monoid (Solo a) -- Defined in ‘GHC.Base’
instance Monoid [a] -- Defined in ‘GHC.Base’
ghci> mappend [1,2] [2,3]
mappend [1,2] [2,3]
[1,2,2,3]
ghci> mappend [1,2] [2,3]
mappend [1,2] [2,3]
[1,2,2,3]
ghci> 